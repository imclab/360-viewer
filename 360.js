// Generated by CoffeeScript 1.6.2
(function() {
  var cacheImgs, fullscreen, i, img, maximize, move, nextTick, rootElem, setStyle, urls;

  urls = (function() {
    var _i, _results;

    _results = [];
    for (i = _i = 1; _i <= 36; i = ++_i) {
      _results.push("testimg/" + i + ".jpg");
    }
    return _results;
  })();

  rootElem = document.getElementById("img360");

  /* Notes {{{1
  
  When targeting mobile devices,  
  and possibly several 360ยบ views on a page,
  memory is more likely to be bottleneck than CPU.
  
  We therefore just preload the compressed images
  into the browsers component cache, 
  and decompress them at render time.
  
  The actual rendering is then just replacing
  the `src` of an image tag, - also making it work
  in non-HTML5 browsers, such as IE8, 
  which we also need to support.
  
  ----
  
  Wanted features
  
  - performant, and working on IE8+,mobile,...
    - component caching
  - rotate
  - zoom
  - labels
  - touch
  */


  /* Util {{{1
  */


  nextTick = function(fn) {
    return setTimeout(fn, 0);
  };

  setStyle = function(elem, obj) {
    var key, val, _results;

    _results = [];
    for (key in obj) {
      val = obj[key];
      _results.push(elem.style[key] = val);
    }
    return _results;
  };

  /* maximize {{{2
  */


  maximize = function(elem) {
    var nextSibling, node, oldbody, parent, _i, _len, _ref;

    oldbody = document.createElement("div");
    oldbody.style.display = "none";
    parent = elem.parentElement;
    nextSibling = elem.nextSibling;
    document.body.appendChild(oldbody);
    _ref = (function() {
      var _j, _len, _ref, _results;

      _ref = document.body.childNodes;
      _results = [];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        node = _ref[_j];
        _results.push(node);
      }
      return _results;
    })();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (node !== oldbody) {
        oldbody.appendChild(node);
      }
    }
    document.body.appendChild(elem);
    return function() {
      var _j, _len1, _ref1;

      _ref1 = (function() {
        var _k, _len1, _ref1, _results;

        _ref1 = oldbody.childNodes;
        _results = [];
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          node = _ref1[_k];
          _results.push(node);
        }
        return _results;
      })();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        node = _ref1[_j];
        document.body.appendChild(node);
      }
      oldbody.remove();
      if (nextSibling) {
        return elem.insertBefore(nextSibling);
      } else {
        return parent.appendChild(elem);
      }
    };
  };

  /* Image caching {{{1 
  
  Creating a temporary DOM object for each image
  is enough to get them loaded.
  */


  cacheImgs = function(urls) {
    var url, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = urls.length; _i < _len; _i++) {
      url = urls[_i];
      _results.push((new Image).src = url);
    }
    return _results;
  };

  cacheImgs(urls);

  /* Create image element {{{1
  */


  img = new Image();

  img.src = urls[0];

  img.onload = function() {
    return setStyle(img, {
      width: img.width + "px",
      height: img.height + "px"
    });
  };

  rootElem.appendChild(img);

  img.onmousemove = function(e) {};

  fullscreen = new Image();

  fullscreen.src = "fullscreenIcon";

  setStyle(fullscreen, {
    position: "absolute",
    top: "0px",
    left: "0px"
  });

  /* Event / gesture handling {{{1
  */


  move = function(x) {
    return img.src = urls[urls.length - 1 - ((20 + Math.round(x / 20)) % urls.length)];
  };

  img.ontouchstart = img.ontouchend = function(e) {
    return e.preventDefault();
  };

  img.ontouchmove = function(e) {
    return move(e.touches[0].clientX);
  };

  img.onmousemove = function(e) {
    return move(e.clientX);
  };

  img.onclick = function() {
    return img.onclick = maximize(img);
  };

}).call(this);
